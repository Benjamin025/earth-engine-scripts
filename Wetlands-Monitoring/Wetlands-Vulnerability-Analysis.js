
/*Audience
Capacity to migrate
documentation of outputs of this tool exit tabular, image, graph
internal information....how the tool generates the outputs...science is it a black box
sensitivity--- robust tool-- error detection ... when datasets are not available... feedback on required datasets
*/
/*===========================================================================================
                          WETLAND VULNERABILITY ANALYSIS TOOL
  ===========================================================================================
BACKGROUND

The DPSIR FRAMEWORK was used to obtain vulnerability wetland indicators 
**Drivers 
**Pressures
**State
**Impact
**Response
                                 
//exposure indicators (threat factors i.e. pressure and cause of threats- drivers)
//Wetland state variables such as seasonality, water quality etc. are used to characterize the resilience of a wetland system
//interaction of the responses with the drivers, pressures, state and impacts can also be evaluated through weighting by expert opinion to effectively include the Response as a resilience component.
// The severity/ impact of threats on the wetland ecosystem services and functions is expressed              
IPCC CONCEPT OF VULNERABILITY ASSESSMENT

EXPOSURE:threat factors (drivers and pressure and cause of threats- drivers
SENSITIVITY
LACK OF RESILIENCE
                    VULNERABILITY= EXPOSURE+ SENSITIVITY-RESILIENCE

/*===========================================================================================
                                            CONTENT
  ===========================================================================================
  *** STEP 1: DEFINING THE STUDY AREA (WETLAND ECOSYSTEM)  ***
  *** STEP 2: LOADING SENTINEL 2 IMAGERY FOR STUDY AREA ***
  *** STEP 3: COMPUTING NORMALISED NDVI ***
  *** STEP 4: COMPUTING NORMALISED NDWI  ***
  *** STEP 5: COMPUTING NORMALISED NDBI ***
  *** STEP 6: COMPUTING NORMALISED POPULATION PRESSURE
  *** STEP 7: COMPUTING NORMALISED DROUGHT/ SPI (OPTIONAL) ***
  *** STEP 8: LOADING AND MANIPULATING LANDCOVER DATA ***
  *** STEP 9: ECOSYSTEM SERVICE VALUATION ***
  *** STEP 10:LOAD AND  NORMALISE INNUDATION DATA ***
  *** STEP 11:LOAD AND NORMALISE WETNESS INDEX DATA***
  *** STEP 12:WETLAND VULNERABILITY COMPUTATIONS ***
  *** STEP 13:ADDING WVA LEGEND ***
  *** STEP 14:WETLAND VULNERABILITY STATISTICS *** 
  *** STEP 15:VISUALIZE DATA IN GOOGLE EARTH ENGINE ***
  *** STEP 16:EXPORT DATA ***

  ===========================================================================================
*/
//------------------------------------------------------------------------------------------------------------------------------------------
//STEP 1: SELECT THE WETLAND ECOSYSTEM FO WETLAND VULNERABILITY ANALYSIS
//---------------------------------------------------------------------------------------------------------------------------------------------

var AOI = ee.FeatureCollection('projects/gee-tenuru/assets/WVA_RCMRD/UG_Wetland_AOI');

//------------------------------------------------------------------------------------------------------------------------------------------
//STEP 2: LOAD SENTINEL 2 IMAGERY DATA AND ADD TO MAP
//---------------------------------------------------------------------------------------------------------------------------------------------



function maskS2clouds(image) {
  var qa = image.select('QA60');

  // Bits 10 and 11 are clouds and cirrus, respectively.
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
      .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  return image.updateMask(mask).divide(10000);
}


//Specify dates for  sentinel imagery to be loaded 

var start_date='2023-01-01';
var end_date='2023-01-30';



var dataset = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                  .filterDate(start_date, end_date)
                  // Pre-filter to get less cloudy granules.
                  .filterBounds(AOI)
                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE',10))
                  .map(maskS2clouds);


var visualization = 
  { min: 0.0, max: 0.3,
  bands: ['B8', 'B4', 'B3'],
};

// Create a single Image by reducing by Mean and clip it to the extent of the geometry

var dataset_mean = dataset.mean()
                    .clip(AOI);
                    
//Print your Image to your console tab to inspect it
print(dataset_mean, 'Median reduced Image');

//Add your Image as a map layer

Map.addLayer(dataset_mean, visualization, ' jan 2020 Mean');


///-----------------------------------------------------------------------------------
//STEP 3: COMPUTING NORMALISED NDVI = (B8 - B4) / (B8 + B4)--interchanges
///----------------------------------------------------------------------------------
//this can be achieved using either simple band operations, .expression or .normalizedDifference

//NDVI = (B8 - B4) / (B8 + B4). the equation is interchanged since we are interested in low NDVI that shows High wetland vulnerability
//Variant 1: Simple band operations
var nir = dataset_mean.select('B4');
var red = dataset_mean.select('B8');
var ndvi = nir.subtract(red).divide(nir.add(red)).rename('NDVI');
print(ndvi, 'NDV1')

// Display the result.
//var ndviParams = {min: -1, max: 1, palette: ['blue', 'white', 'green']};
//Map.addLayer(ndvi, ndviParams, 'NDV1');


//the resulting inverted NDVI layer is Normalised at a scale of 0-100
//get NDVI min max to be used in min-max normalisation//////
var statsndvi = ndvi.reduceRegion({
reducer: ee.Reducer.minMax(),
geometry: AOI,
scale: 10,
maxPixels: 10e9
});
print(statsndvi, 'min_maxNDVI');

// normalise the NDVI from 0 to 100
var norm_NDVI = ndvi.unitScale(statsndvi.get('NDVI_min'), 
                                       statsndvi.get('NDVI_max')).multiply(100);

//print(norm_NDVI);
// display results
var ndvinormParams = {min: 0, max: 100, palette: ['blue', 'white', 'green']};
Map.addLayer(norm_NDVI, ndvinormParams,"normalized NDVI");




/*--------------------------------------------------------------------------------------
//STEP 4: COMPUTING NORMALISED NDWI 
----------------------------------------------------------------------------------------*/
//the bands in the NDWI equation are interchanged to achieve /--bands interchanged ince we are interested in low NDWI that shows High wetland vulnerability
var swir = dataset_mean.select('B3');
var green = dataset_mean.select('B11');
var ndwi = green.subtract(swir).divide(green.add(swir)).rename('NDWI');
print(ndwi, 'NDW1')

// Display the result.
//var ndwiParams = {min: -1, max: 1, palette: ['blue', 'white', 'green']};
//Map.addLayer(ndwi, ndwiParams, 'NDW1');


// below is a code segement for normalising the reversed NDWI layer
//get NDWI min max to be used in min max normalisation
var statsndwi = ndwi.reduceRegion({
reducer: ee.Reducer.minMax(),
geometry: AOI,
scale: 10,
maxPixels: 10e9
});
print(statsndwi, 'min_maxNDWI');

// normalise the NDWI from 0 to 100
var norm_NDWI = ndwi.unitScale(statsndwi.get('NDWI_min'), 
                                       statsndwi.get('NDWI_max')).multiply(100);

//print(norm_NDWI);
// display results of normalised layer on the map 
var ndwinormParams = {min: 0, max: 100, palette: ['blue', 'white', 'green']};
Map.addLayer(norm_NDWI, ndwinormParams,"normalized NDWI");


/*-------------------------------------------------------------------------------------
//STEP 5: COMPUTING NORMALISED NDBI 
------------------------------------------------------------------------------------------*/

var swir = dataset_mean.select('B11');
var nir = dataset_mean.select('B8');
var ndbi = swir.subtract(nir).divide(swir.add(nir)).rename('NDBI');
print(ndbi, 'NDBI')
// Display the result.
//var ndbiParams = {min: -1, max: 1, palette: ['yellow', 'cyan', 'red']};
//Map.addLayer(ndbi, ndbiParams, 'NDB1');

//Normalisation of NDBI
//get NDBI min max //////
var stats = ndbi.reduceRegion({
reducer: ee.Reducer.minMax(),
geometry: AOI,
scale: 10,
maxPixels: 10e9
});
print(stats, 'min_maxNDBI');

// normalise the NDBI from 0 to 100
var norm_NDBI = ndbi.unitScale(stats.get('NDBI_min'), 
                                       stats.get('NDBI_max')).multiply(100);

//print(norm_NDBI);
// display results
var ndbinormParams = {min: 0, max: 100, palette: ['yellow', 'cyan', 'red']};
Map.addLayer(norm_NDBI, ndbinormParams,"normalized NDBI");




/*------------------------------------------------------------------------------
//STEP 6: COMPUTING NORMALISED POPULATION PRESSURE
--------------------------------------------------------------------------------*/
// Load the WorldPop ImageCollection and filter by AOI
var pop = ee.ImageCollection('WorldPop/GP/100m/pop').filterBounds(AOI);

// Print the ImageCollection to check contents
print('Population ImageCollection:', pop);

// Convert ImageCollection to a list
var list_img = pop.toList(pop.size());

// Retrieve images from the list with appropriate indices
var img2000Index = 63; // Adjust index as needed
var img2020Index = 83; // Adjust index as needed

// Select the images
var img2000 = ee.Image(list_img.get(img2000Index));
var img2020 = ee.Image(list_img.get(img2020Index));

// Print the images to ensure they are correctly loaded
print('Population Image 2000:', img2000);
print('Population Image 2020:', img2020);

// Calculate population pressure
var popPressure = img2020.subtract(img2000).divide(20).rename('popPressure');

//Print the population pressure image to check results
//print('Population Pressure:', popPressure);

// Display population pressure result
var popParams = {
  bands: ['popPressure'],
  min: 0.0,
  max: 50.0,
  palette: ['24126c', '1fff4f', 'd4ff50']
};

// Clip and add to the map
var pop_mean = popPressure.clip(AOI);
Map.addLayer(pop_mean, popParams, 'Population Pressure');


// Normalise population pressure to a scale of 0 to 100
var statsPop = popPressure.reduceRegion({reducer: ee.Reducer.minMax(), geometry: AOI, scale: 10, maxPixels: 1e9});
var norm_pop = popPressure.unitScale(statsPop.get('popPressure_min'), statsPop.get('popPressure_max')).multiply(100);

// display results
var popnormParams = {min: 0, max: 100, palette: ['24126c', '1fff4f', 'd4ff50']};
Map.addLayer(norm_pop.clip(AOI), popnormParams,"normalized pop");


/*---------------------------------------------------------------------------------------
//STEP 7: COMPUTING NORMALISED DROUGHT/ SPI
-------------------------------------------------------------------------------------------*/
//////////////////////////////////Drought /SPI///////////////////////////////////////////////////

/*var CHIRPS = ee.ImageCollection('UCSB-CHG/CHIRPS/DAILY')
                  .filter(ee.Filter.date('2018-05-01', '2018-05-03'))
                  .filterBounds(geometry);
var precipitation = CHIRPS.select('precipitation');
var precipitationVis = {
  min: 1,
  max: 17,
  palette: ['001137', '0aab1e', 'e7eb05', 'ff4a2d', 'e90000'],
};

//clip geometry
var spi_mean=precipitation.mean().clip(geometry);
Map.addLayer(precipitation, precipitationVis, 'Precipitation');

//var firstImage=ee.Date(ee.List(CHIRPS.get('date_range')).get(0)); https://www.un-spider.org/advisory-support/recommended-practices/recommended-practice-drought-monitoring-spi/step-by-step


/*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 8: LOADING AND MANIPULATING LANDCOVER DATA 
----------------------------------------------------------------------------------------------------------------------------------------*/
/////////////////////////////////////////landcover//////////////////////////////////////

var landcover = ee.ImageCollection('ESA/WorldCover/v100').first();

var landviz = {
  bands: ['Map'],
};

var landcover_mean=landcover.clip(AOI);
Map.addLayer(landcover_mean, landviz, 'landcover 2021');


//////find rrange of LULC from esa dataset
///var statslulc =  landcover_mean.reduceRegion({
///reducer: ee.Reducer.minMax(),
///geometry:  geometry,
///scale: 10,
///maxPixels: 10e9
///});
///print(statslulc);
//List the class names
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//10 Tree cover, 20 Shrubland,30 Grassland, 40 Cropland, 50 Built-up, 60 Bare /sparse vegetation, 
//70 Snow and Ice, 80 Permanent water bodies, 90 Herbaceous wetland, 95 Mangroves, 100 Moss and lichen
//var values=ee.List(landcover.get('Map_class_values'));
//var names=ee.List(landcover.get('Map_class_names'));
//print (names, values);


var fromList = [10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100];

// A corresponding list of replacement values (10 becomes 1, 20 becomes 2, etc) according to vulnerability levels
var toList =   [ 10,  20,  30,  40,  100,  70,  10,  10,  10,  20,  50];

// Replace pixel values in the image. If the image is multi-band, only the
// remapped band will be returned. The returned band name is "remapped".
// Input image properties are retained in the output image.
var ReclassLandCover = landcover.remap({
  from: fromList,
  to: toList,
  defaultValue: 0,
  bandName: 'Map'
  
});
var ReclassLandCover_mean=ReclassLandCover.clip(AOI);

// Display the original and remapped images. Note that similar land cover
// classes in the original image are grouped into aggregate classes by
// from â†’ to value mapping.
//Map.addLayer(img, null, 'Original image');
Map.addLayer(ReclassLandCover_mean, {
    min: 0, max: 100,
    palette:'darkgreen, lightgreen, red, white, blue, lightblue'
  }, 'LandcoverReclass');
  
  
 
  /*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 9: ECOSYSTEM SERVICE VALUATION
----------------------------------------------------------------------------------------------------------------------------------------*/
  
  
//////////////////////////////////////ecosystem_services///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//10 Tree cover, 20 Shrubland,30 Grassland, 40 Cropland, 50 Built-up, 60 Bare /sparse vegetation, 
//70 Snow and Ice, 80 Permanent water bodies, 90 Herbaceous wetland, 95 Mangroves, 100 Moss and lichen

// create a function to compute area of each landcover class 
function areacomputation (image){
var areaImagef =  image.multiply(ee.Image.pixelArea())
var area= areaImagef.reduceRegion({
  reducer: ee.Reducer.sum(),
  geometry: AOI,
  scale: 500,
  maxPixels: 1e10
  })
var AreaHectares = ee.Number(
  area.get('Map')).divide(1e4).round()
 return AreaHectares;
}

// compute area of each landcover class and multiply by the ecosystem value 
///////10 Tree cover /// ecosy=1588USD
var Tree_cover = landcover.eq(10); 
var areaTree_cover=areacomputation(Tree_cover).multiply(1588);
print(areaTree_cover);
///////area shrubland /// ecosy=2871USD
var Shrubland = landcover.eq(20);
var areaShrubland=areacomputation(Shrubland).multiply(2871);
print(areaShrubland);
////Area 30 Grassland /// ecosy=2871USD
var Grassland = landcover.eq(30);
var areaGrassland=areacomputation(Grassland).multiply(2871);
print(areaGrassland);
///area 40 Cropland, /// ecosy=2871USD
var Cropland = landcover.eq(40);
var areaCropland=areacomputation(Cropland).multiply(2871);
print(areaCropland);
// area 50 Built-up,\\ /// ecosy=0 USD
var Built_up = landcover.eq(50);
var areaBuilt_up=areacomputation(Built_up).multiply(0);
print(areaBuilt_up);
/// area 60 Bare /sparse vegetation, /// ecosy=0 USD
var Bare = landcover.eq(60);
var areaBare=areacomputation(Bare).multiply(0);
print(areaBare);
///70 Snow and Ice, /// ecosy=0USD
var snow = landcover.eq(70);
var areasnow=areacomputation(snow).multiply(0);
print(areasnow);

//area 80 Permanent water bodies,/// ecosy=4267USD
var water = landcover.eq(80);
var areawater=areacomputation(water).multiply(4267);
print(areawater);
// area 90 Herbaceous wetland/// Ecos=25681USD
var wetland = landcover.eq(90);
var areawetland=areacomputation(wetland).multiply(25681);
print(areawetland);
//area 95 Mangroves, 
var Mangroves = landcover.eq(95);
var areaMangroves=areacomputation(Mangroves).multiply(3013); /// ecosy=3013USD
print(areaMangroves);
// area 100 Moss and lichen /// ecosy=0USD
var Moss = landcover.eq(100);
var areaMoss=areacomputation(Moss).multiply(0);
print(areaMoss); 

// multiply area with ecosystem valuation  and place in list

var ecoList =   [ areaTree_cover,  areaShrubland,  areaGrassland, areaCropland, areaBuilt_up, areaBare, areasnow, areawater,  areawetland, areaMangroves,  areaMoss];

// compute ecosystem services
var ecosystemService = landcover.remap({
  from: fromList,
  to: ecoList,
  defaultValue: 0,
  bandName: 'Map'
  
});

// normalise the ecosystem service map from 0 to 100

//get min max  //////
var statseco =  ecosystemService.reduceRegion({
reducer: ee.Reducer.minMax(),
geometry:  AOI,
scale: 10,
maxPixels: 10e9
});
print(statseco, 'min_max');

var norm_eco =  ecosystemService.unitScale(statseco.get('remapped_min'), 
                                       statseco.get('remapped_max')).multiply(100);

//print(norm_eco);
///clip 
var ecosystemService_clip=norm_eco.clip(AOI);
// display results
var econormParams = {min: 0, max: 100, palette: ['24126c', '1fff4f', 'd4ff50']};
Map.addLayer(ecosystemService_clip, econormParams,"normalized eco");







/*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 10: LOAD AND  NORMALISE INNUDATION DATA
----------------------------------------------------------------------------------------------------------------------------------------*/
//////////////////////////////////innudation///////////////////////////////////////////

var innudation = ee.Image('JRC/GSW1_4/GlobalSurfaceWater');

var visualizationinnu = {
  bands: ['occurrence'],
  min: 0.0,
  max: 100.0,
  palette: ['ffffff', 'ffbbbb', '0000ff']
};

var innudation_clip=innudation.select('occurrence').clip(AOI);

print (innudation_clip, 'innu')
// Normalise innudation layer

var innustats = innudation_clip.reduceRegion({
reducer: ee.Reducer.minMax(),
geometry: AOI,
scale: 10,
maxPixels: 10e9
});
print(innustats, 'min_maxinnu');

// normalise the clipped innudation layer from 0 to 100
var norm_innu = innudation_clip.unitScale(innustats.get('occurrence_min'), 
                                       innustats.get('occurrence_max')).multiply(100);

//print(norm_WVA);
// display results
Map.addLayer(norm_innu, visualizationinnu, 'norm_innudation');





/*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 11: LOAD AND NORMALISE WETNESS INDEX DATA
----------------------------------------------------------------------------------------------------------------------------------------*/
///////////////////////////wetness index/ moisture/////////////////////////////
var datasetmoisture = ee.Image('OpenLandMap/SOL/SOL_WATERCONTENT-33KPA_USDA-4B1C_M/v01');

var visualizationm = {
  bands: ['b0'],
  min: 0.0,
  max: 52.9740182135385,
  palette: [
    'd29642','eec764','b4ee87','32eeeb','0c78ee','2601b7',
    '083371',
  ]
};

//print (datasetmoisture.select('b0'), 'moistureee');

var moisture_clip=datasetmoisture.select('b0').clip(AOI);

// Normalise moisture layer

var moisturestats = moisture_clip.reduceRegion({
reducer: ee.Reducer.minMax(),
geometry: AOI,
scale: 10,
maxPixels: 10e9
});
print(moisturestats, 'min_maxmoisture');

// normalise the clipped imoisture  layer from 0 to 100
var norm_moisture = moisture_clip.unitScale(moisturestats.get('b0_min'), 
                                       moisturestats.get('b0_max')).multiply(100);

Map.addLayer(norm_moisture, visualizationm, 'Soil water content at 33kPa (field capacity)');
print(moisture_clip, 'moisture')




////////////////////////////land degradation//////////////////////////////////////////

//////////////////////////  wetland fragmentation/////////////////////////////////

/*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 12: WETLAND VULNERABILITY COMPUTATIONS
----------------------------------------------------------------------------------------------------------------------------------------*/

/////////////////user Defined weights//////////////////////////////////////
var textboxstyle={'width': '200px'}

var NDWI_V = ui.Textbox({
  value: 40.0,
  placeholder: 'the weight for NDWI...',
  style:textboxstyle,
  onChange: function(value) {
    return(value);
  
  }
  
});
//print(NDWI_V);


///////////////////////////////tool//////////////////////////////////////////

///Exposure ---Degredation, drought, NDBI, LandCover, Population
var Exposure=(norm_NDBI.multiply(30).add(norm_pop.multiply(40)).add(ReclassLandCover_mean.multiply(30))).divide(3).rename('exposure');

//Sensitivity --NDVI, NDWI, we subtract off Ecosytem services because  a wetland that gives much lower benef,
var sensitivity=(norm_NDVI.multiply(30).add(norm_NDWI.multiply(40)).subtract(ecosystemService_clip.multiply(30))).divide(3).rename('sensitivity');

// Resilience
var resilience=(norm_moisture);

////To be recomputed to include resilience
var WVA=(Exposure.add(sensitivity).subtract(resilience)).rename('WVA');
print (WVA);

//Normalisation of WVA Layer
//get WVA min max //////
var WVAstats = WVA.reduceRegion({
reducer: ee.Reducer.minMax(),
geometry: WVA.geometry(),
scale: 10,
maxPixels: 10e9
});
print(WVAstats, 'min_maxWVA');

// normalise the WVA from 0 to 100
var norm_WVA = WVA.unitScale(WVAstats.get('WVA_min'), 
                                       WVAstats.get('WVA_max')).multiply(100);

//print(norm_WVA);
// display results
var WVAnormParams = {min: 0, max: 100, palette: ['green', 'yellow', 'red']};
Map.addLayer(norm_WVA, WVAnormParams,"normalized WVA");



////reclass vulnerability values
// Remap values.
var WVAreclass = ee.Image(1)
      .where(norm_WVA.gt(10).and(norm_WVA.lte(20)), 1)
      .where(norm_WVA.gt(20).and(norm_WVA.lte(30)), 2)
      .where(norm_WVA.gt(30).and(norm_WVA.lte(40)), 3)
      .where(norm_WVA.gt(40).and(norm_WVA.lte(50)), 4)
      .where(norm_WVA.gt(50).and(norm_WVA.lte(100)), 5)
print(WVAreclass)
// create colors for those classifications
var visparams = {
   "opacity": 1,
    "min": 1,
    "max": 5,
    "palette": ["147218", "7cb815", "f2fe2a", "ffac18", "fe3c19"]
}
var WVAreclass_clip=WVAreclass.clip(AOI);
Map.addLayer(WVAreclass_clip, visparams, 'WVAreclass')



/*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 13:  ADDING WVA LEGEND
----------------------------------------------------------------------------------------------------------------------------------------*/
// set position of panel
var legend = ui.Panel({
  style: {
    position: 'bottom-left',
    padding: '8px 15px'
  }
});
// Create legend title
var legendTitle = ui.Label({
  value: 'Wetland Vulnerability',
  style: {
    fontWeight: 'bold',
    fontSize: '18px',
    margin: '0 0 4px 0',
    padding: '0'
    }
});
 
// Add the title to the panel
legend.add(legendTitle);

// Creates and styles 1 row of the legend.
var makeRow = function(color, name) {
 
      // Create the label that is actually the colored box.
      var colorBox = ui.Label({
        style: {
          backgroundColor: '#' + color,
          // Use padding to give the box height and width.
          padding: '10px',
          margin: '0 0 6px 0'
        }
      });
 
      // Create the label filled with the description text.
      var description = ui.Label({
        value: name,
        style: {margin: '0 0 4px 6px'}
      });
 
      // return the panel
      return ui.Panel({
        widgets: [colorBox, description],
        layout: ui.Panel.Layout.Flow('horizontal')
      });
};
 
//  Palette with the colors
var palette =["147218", "7cb815", "f2fe2a", "ffac18", "fe3c19"];
 
// name of the legend
var names = ['VERY LOW','LOW','MEDIUM','HIGH', 'VERY HIGH'];
 
// Add color and and names
for (var i = 0; i < 5; i++) {
  legend.add(makeRow(palette[i], names[i]));
  }  
 
// add legend to map (alternatively you can also print the legend to the console)
Map.add(legend);

//////////////////////////////////////////////////ADD Shapefile for Uganda wetlands//////
/*/ Load a collection of uganda wetlands.
var wetlands_ug = ee.FeatureCollection('projects/ee-allanmazimwe/assets/wetlands_Uganda')
                                        .filter(ee.Filter.eq('Wet_system', '23'));
                                        
// Add reducer output to the Features in the collection.
var WetMeansFeatures = image.reduceRegions({
  collection: Wet_Name,
  reducer: ee.Reducer.mean(),
  scale: 30,
});



// Print the first feature, to illustrate the result.
print(ee.Feature(wetMeansFeatures.first()).select(image.bandNames()));


//overlay wetland boundaries


//compute zonal stats and show them piechart


/*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 14: WETLAND VULNERABILITY STATISTICS 
----------------------------------------------------------------------------------------------------------------------------------------*/

//////////////////////////////////////////////////create WVA chart/////////////////////////
// Create Class names
var Vulnerability_classes= ['verylow', 'low', 'Medium', 'high', 'VeryHigh'];
// Create an area image and convert to Hectares
var areaWVAreclass = ee.Image.pixelArea().divide(1e4);
// Add the band containing classes
var areaImageWithClass = areaWVAreclass.addBands(WVAreclass);
print (areaImageWithClass, 'area')


// Create a chart

var options = {
    hAxis: {title: 'Wetland Vulnerability Classes'},
    vAxis: {title: 'Area (Hectares)'},
    title: 'Wetland vulnerability Analysis',
    series: { // You can change these to be whatever colours you'd like. Simply add numbers to match how many classes you have
      0: {color: "147218"},
      1: {color: "7cb815"},
      2: {color: "f2fe2a"},
      3: {color: "ffac18"},
      4: {color: "fe3c19"}
      
    }
  };


var chart = ui.Chart.image.byClass({
  image: areaImageWithClass,
  classBand: 'constant',
  region: AOI,
  reducer: ee.Reducer.sum(),
  scale: 30
  
}).setSeriesNames(Vulnerability_classes);
chart.setOptions( options );
//print(chart);

  


/*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 16:EXPORT DATA ***
----------------------------------------------------------------------------------------------------------------------------------------*/

/*
//////////export sentinel image to drive ///////////

Export.image.toDrive({
  image: dataset_mean,
  description: 'sentinelimage',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});


//////////export Norm NDVI to drive ///////////

Export.image.toDrive({
  image: norm_NDVI,
  description: 'NDVI_norm100',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});


//////////export Norm NDWI to drive ///////////

Export.image.toDrive({
  image: norm_NDWI,
  description: 'NDWI_norm100',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});


///////////export Norm NDBI to drive ///////////

Export.image.toDrive({
  image: norm_NDBI,
  description: 'NDBI_norm100',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});


  ///////////export normalised population layer purposes///////////

Export.image.toDrive({
  image: norm_pop,
  description: 'norm_pop_norm100',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});

 
  ///////////export normalised landcover layer purposes///////////

Export.image.toDrive({
  image: ReclassLandCover_mean,
  description: 'Landcover_norm100',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});


///////////export ecosystem services layer purposes///////////

Export.image.toDrive({
  image: ecosystemService_clip,
  description: 'ecosystemServices_norm100',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});



// Export innudation image to drive 

Export.image.toDrive({
  image: norm_innu,
  description: 'normalisedinnudation',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});

/// Export soil moisture image to drive 

Export.image.toDrive({
  image: norm_moisture,
  description: 'normalisedmoisture',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});

///////////export for WVA data///////////

Export.image.toDrive({
  image: WVAreclass,
  description: 'WVAreclass',
  scale: 10,
  region: AOI,
  maxPixels: 1000000000000,
  crs: 'EPSG:4326',
  folder: 'WVATool'
});
*/


/*-----------------------------------------------------------------------------------------------------------------------------------
//STEP 15:VISUALIZE DATA IN GOOGLE EARTH ENGINE ***
----------------------------------------------------------------------------------------------------------------------------------------*/
  
//---------------------------------- MAP PRODUCTION --------------------------------//

//-------------------------- Display the results on the map -----------------------//

// set position of panel where the results will be displayed 
var results = ui.Panel({
  style: {
    position: 'bottom-left',
    padding: '8px 15px',
    width: '450px'
  }
});

//Prepare the visualtization parameters of the labels 
var textVis = {
  'margin':'0px 8px 2px 0px',
  'fontWeight':'bold'
  };
var numberVIS = {
  'margin':'0px 0px 15px 0px', 
  'color':'bf0f19',
  'fontWeight':'bold'
  };
var subTextVis = {
  'margin':'0px 0px 5px 0px',
  'fontSize':'12px',
  'color':'grey',
  'text-align': 'justify'
  };

var titleTextVis = {
  'margin':'0px 0px 15px 0px',
  'fontSize': '20px', 
  'font-weight':'bold', 
  'color': '3333ff'
  };

// Create lables of the results 
// Titel and time period
var title = ui.Label('Wetland Vulnerability Analysis', titleTextVis);
var text1 = ui.Label('WVA Image Dates:',textVis);
var number1 = ui.Label(start_date.concat(" and ",end_date),numberVIS);

var text9 = ui.Label('Wetland Vulnerability Conceptualisation',textVis);

// Alternatively, print dates of the selected tiles
//var number1 = ui.Label('Please wait...',numberVIS); 
//(after_collection).evaluate(function(val){number1.setValue(val)}),numberVIS;

// Estimated Wetland vulnerabilty
var text2 = ui.Label('Estimated wetland Vulnerability:',textVis);
var text2_2 = ui.Label('Please wait...',subTextVis);
//dates(after_collection).evaluate(function(val){text2_2.setValue('based on Senintel-1 imagery '+val)});
//var number2 = ui.Label('Please wait...',numberVIS); 
//flood_area_ha.evaluate(function(val){number2.setValue(val+' hectares')}),numberVIS;

var text8 = ui.Label('Wetlands, like many other ecosystems, are also affected by many pressures due to human activity and climate change. To Assess vulnerability of wetlands , the DRIVERS, PRESSURES, STATE, IMPACT AND RESPONSE (DPSIR) Framework is used to obtain vulnerability indicators. Exposure indicators are threats (Drivers and pressures), the sensitivity are the state and impact  while the Resilience are the response factors. ',subTextVis)
var text8_1 = ui.Label('VULNERABILITY=EXPOSURE+SENSITIVITY-RESILENCE',numberVIS)

/////////add boxes for feeding in weight values

var textw1 = ui.Label(NDWI_V.getPlaceholder(), textVis)



//////////////////////////////////////////////////

// Disclaimer
var text6 = ui.Label('Disclaimer: This product has been derived automatically without validation data. All geographic information has limitations due to the scale, resolution, date and interpretation of the original source materials. No liability concerning the content or the use thereof is assumed by the producer.',subTextVis)

// Produced by...
var text7 = ui.Label('Script produced by: ESSIPs 2024 under GMES and Africa program', subTextVis)

// Add the labels to the panel 
results.add(ui.Panel([
        title,
        text9,
        text8,
        text8_1,
        //NDWI_V,
       // textw1,
        text1,
        number1,
        text2,
        text2_2,
       chart,
        text6,
        text7]
      ));

// Add the panel to the map 
//Map.add(results);
ui.root.insert(2,results)


/////////////////////////////
Map.centerObject(AOI, 8);

//Map.addLayer(dataset.mean(), visualization, 'RGB');
